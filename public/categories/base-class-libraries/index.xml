<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Base Class Libraries on A Sysadmin, An SRE, and a DevOps Walk Into a Bar</title>
    <link>https://stevenmurawski.com/categories/base-class-libraries/</link>
    <description>Recent content in Base Class Libraries on A Sysadmin, An SRE, and a DevOps Walk Into a Bar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jul 2009 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://stevenmurawski.com/categories/base-class-libraries/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Deep Dive: Error Handling – Error Types (part 1)</title>
      <link>https://stevenmurawski.com/2009/07/01/deep-dive-error-handling-error-types-part-1/</link>
      <pubDate>Wed, 01 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/07/01/deep-dive-error-handling-error-types-part-1/</guid>
      <description>I started looking a little deeper at error handling in PowerShell after this StackOverflow question. PowerShell has two kinds of errors – terminating errors and non-terminating errors.
Terminating errors are the errors that can stop command execution cold. Non-terminating errors provided an additional challenge, as you need to be notified of failed operations and continue with pipeline operations. To deal with this issue and to provide additional output options, PowerShell employs the concept of streams.</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Namespaces (Part 5)</title>
      <link>https://stevenmurawski.com/2009/04/01/exploring-the-net-framework-with-powershell-namespaces-part-5/</link>
      <pubDate>Wed, 01 Apr 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/04/01/exploring-the-net-framework-with-powershell-namespaces-part-5/</guid>
      <description>One concept that is central to the understanding of the layout of classes in the Base Class Libraries is the Namespace. Namespaces are a method of providing context for classes (and other constructs like Enums and Structs), allowing developers to group related classes and not worry about name collisions with development in other areas. In the Base Class Libraries, the root namespace is the System namespace. The System namespace defines a large amount of the base types, like Object (which all classes derive from), String, DateTime, Boolean, and numerous others.</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Constructors (Part 3)</title>
      <link>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-constructors-part-3/</link>
      <pubDate>Sun, 01 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-constructors-part-3/</guid>
      <description>In part 2(a &amp;amp; b) of this series, we talked about methods and looked at ways to view their overloads, or ways to call them.&amp;#160; We also looked at the objects returned from a method call.&amp;#160; In this post, we are going to explore a special kind of method called the constructor.
A constructor is a method whose job is to create the object that you want to work with.&amp;#160; When I created the Ping object</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Static Members (Part 4)</title>
      <link>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-static-members-part-4/</link>
      <pubDate>Sun, 01 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-static-members-part-4/</guid>
      <description>In our Exploring the .NET Framework series, we’ve covered some terminology, creating instances of objects and calling methods. In today’s installment, we are going to look at using static members - methods and properties. Static methods are methods that a class (or type) make available without needing to create an instance of the class. Similarly, static properties are properties that you can access without needing an instance of the class.</description>
    </item>
    
    <item>
      <title>How To Send E-Mail From PowerShell</title>
      <link>https://stevenmurawski.com/2009/03/01/how-to-send-e-mail-from-powershell/</link>
      <pubDate>Sun, 01 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/03/01/how-to-send-e-mail-from-powershell/</guid>
      <description>In my Exploring the .NET Framework series, I introduced the System.Net.Mail.MailMessage class. Being able to create a MailMessage object is all well and good, but if you can’t send it, it’s really not helpful.
Updated - This mainly applies to V1 of PowerShell. V2 has a built in cmdlet for this purpose. To send an email from PowerShell using the .NET Framework, you can use the System.Net.Mail.SMTPClient class.
First, you need to create your MailMessage</description>
    </item>
    
    <item>
      <title>Tip: Sneaky Storage – What’s in your AppDomain?</title>
      <link>https://stevenmurawski.com/2009/03/01/tip-sneaky-storage-whats-in-your-appdomain/</link>
      <pubDate>Sun, 01 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/03/01/tip-sneaky-storage-whats-in-your-appdomain/</guid>
      <description>Since PowerShell is built on .NET, there is a AppDomain (I’ll go into more detail in a later post) which has a lot of information about the .NET environment (what assemblies are loaded, etc..).
One feature that the AppDomain has is to store globally accessible name/value pairs.&amp;#160; Normally, variables in PowerShell should handle most of your “in-process” storage needs, but for the times that they don’t, you have your AppDomain.</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework With PowerShell – Terminology (Part 1)</title>
      <link>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-terminology-part-1/</link>
      <pubDate>Sun, 01 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-terminology-part-1/</guid>
      <description>PowerShell opens up the .NET Framework for a large new group of consumers, IT Pro’s (or systems administrators). Microsoft developers have been working for years with the .NET Framework and now that rich sea of resources is available from our command line. One of the first hurdles that many IT Pro’s come across when trying to see where the .NET Framework fits into their workflow is the terminology. Before we start digging into the guts of the .</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Calling a Method (Part 2a)</title>
      <link>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2a/</link>
      <pubDate>Sun, 01 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2a/</guid>
      <description>Last week, I defined a number of terms that we’ll be exposed to as we delve into how and why PowerShell is an object oriented shell and how to use it to explore .NET Framework which it is built upon. Now, let’s take a look at how some of these terms surface themselves in PowerShell.
One of the most common tasks you might encounter is needing to ping a computer. There is ping.</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Calling a Method (Part 2b)</title>
      <link>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2b/</link>
      <pubDate>Sun, 01 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2b/</guid>
      <description>Continuing from where I left off last week, we were created an instance of the System.Net.NetworkInformation.Ping class and looked at the different ways (overloads) that we can call the Send method.&amp;#160; Now that we’ve seen how we can create Ping objects, let’s take advantage of options for creating some custom ping packets and examine the return object.
PS C:&amp;amp;gt; $encoder = new-object System.Text.ASCIIEncoding
PS C:&amp;amp;gt; $bytes = $encoder.Getbytes(&amp;lsquo;Hello From Steve&amp;rsquo;)</description>
    </item>
    
  </channel>
</rss>