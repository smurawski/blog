<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on A Sysadmin, An SRE, and a DevOps Walk Into a Bar</title>
    <link>https://stevenmurawski.com/categories/introduction/</link>
    <description>Recent content in Introduction on A Sysadmin, An SRE, and a DevOps Walk Into a Bar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Apr 2009 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://stevenmurawski.com/categories/introduction/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Namespaces (Part 5)</title>
      <link>https://stevenmurawski.com/2009/04/01/exploring-the-net-framework-with-powershell-namespaces-part-5/</link>
      <pubDate>Wed, 01 Apr 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/04/01/exploring-the-net-framework-with-powershell-namespaces-part-5/</guid>
      <description>One concept that is central to the understanding of the layout of classes in the Base Class Libraries is the Namespace. Namespaces are a method of providing context for classes (and other constructs like Enums and Structs), allowing developers to group related classes and not worry about name collisions with development in other areas. In the Base Class Libraries, the root namespace is the System namespace. The System namespace defines a large amount of the base types, like Object (which all classes derive from), String, DateTime, Boolean, and numerous others.</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Constructors (Part 3)</title>
      <link>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-constructors-part-3/</link>
      <pubDate>Sun, 01 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-constructors-part-3/</guid>
      <description>In part 2(a &amp;amp; b) of this series, we talked about methods and looked at ways to view their overloads, or ways to call them.&amp;#160; We also looked at the objects returned from a method call.&amp;#160; In this post, we are going to explore a special kind of method called the constructor.
A constructor is a method whose job is to create the object that you want to work with.&amp;#160; When I created the Ping object</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Static Members (Part 4)</title>
      <link>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-static-members-part-4/</link>
      <pubDate>Sun, 01 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/03/01/exploring-the-net-framework-with-powershell-static-members-part-4/</guid>
      <description>In our Exploring the .NET Framework series, we’ve covered some terminology, creating instances of objects and calling methods. In today’s installment, we are going to look at using static members - methods and properties. Static methods are methods that a class (or type) make available without needing to create an instance of the class. Similarly, static properties are properties that you can access without needing an instance of the class.</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework With PowerShell – Terminology (Part 1)</title>
      <link>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-terminology-part-1/</link>
      <pubDate>Sun, 01 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-terminology-part-1/</guid>
      <description>PowerShell opens up the .NET Framework for a large new group of consumers, IT Pro’s (or systems administrators). Microsoft developers have been working for years with the .NET Framework and now that rich sea of resources is available from our command line. One of the first hurdles that many IT Pro’s come across when trying to see where the .NET Framework fits into their workflow is the terminology. Before we start digging into the guts of the .</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Calling a Method (Part 2a)</title>
      <link>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2a/</link>
      <pubDate>Sun, 01 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2a/</guid>
      <description>Last week, I defined a number of terms that we’ll be exposed to as we delve into how and why PowerShell is an object oriented shell and how to use it to explore .NET Framework which it is built upon. Now, let’s take a look at how some of these terms surface themselves in PowerShell.
One of the most common tasks you might encounter is needing to ping a computer. There is ping.</description>
    </item>
    
    <item>
      <title>Exploring the .NET Framework with PowerShell – Calling a Method (Part 2b)</title>
      <link>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2b/</link>
      <pubDate>Sun, 01 Feb 2009 00:00:00 +0000</pubDate>
      
      <guid>https://stevenmurawski.com/2009/02/01/exploring-the-net-framework-with-powershell-calling-a-method-part-2b/</guid>
      <description>Continuing from where I left off last week, we were created an instance of the System.Net.NetworkInformation.Ping class and looked at the different ways (overloads) that we can call the Send method.&amp;#160; Now that we’ve seen how we can create Ping objects, let’s take advantage of options for creating some custom ping packets and examine the return object.
PS C:&amp;amp;gt; $encoder = new-object System.Text.ASCIIEncoding
PS C:&amp;amp;gt; $bytes = $encoder.Getbytes(&amp;lsquo;Hello From Steve&amp;rsquo;)</description>
    </item>
    
  </channel>
</rss>